<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Ada çš„æ³•å¾‹èµ„æ–™ä¸»é¡µ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
      background-color: #f2f4f7;
      margin: 0;
      padding: 20px;
      color: #333;
      line-height: 1.5;
    }

    h1 {
      color: #003366;
      font-size: 22px;
      margin-bottom: 10px;
      text-align: center;
    }

    p {
      text-align: center;
      font-size: 13px;
      color: #666;
      margin-bottom: 20px;
    }

    #searchInput {
      display: block;
      margin: 0 auto 20px;
      padding: 10px 16px;
      width: 90%;
      max-width: 500px;
      border: 1px solid #ccc;
      border-radius: 24px;
      font-size: 14px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    #loading {
      text-align: center;
      font-size: 13px;
      color: #999;
      margin-bottom: 10px;
    }

    ul#mhtmlList {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
      padding: 0;
      margin: 0;
      list-style: none;
    }

    ul#mhtmlList li {
      background: #fff;
      border-radius: 10px;
      padding: 14px;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
      box-sizing: border-box;
    }

    ul#mhtmlList li:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      transform: translateY(-1px);
    }

    ul#mhtmlList li a {
      font-weight: 600;
      color: #007acc;
      text-decoration: none;
      font-size: 14px;
      word-break: break-all;
    }

    ul#mhtmlList li a:hover {
      text-decoration: underline;
    }

    .file-meta {
      margin-top: 6px;
      font-size: 12px;
      color: #999;
    }

    #noResults {
      display: none;
      color: #888;
      margin-top: 20px;
      font-size: 14px;
      text-align: center;
    }

    .scroll-buttons {
      position: fixed;
      right: 20px;
      bottom: 40px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 999;
    }

    .scroll-buttons button {
      background-color: #007acc;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transition: background-color 0.2s ease;
    }

    .scroll-buttons button:hover {
      background-color: #005fa3;
    }
  </style>
</head>
<body>
  <h1>Ada çš„æ³•å¾‹èµ„æ–™ä¸»é¡µ</h1>
  <p>ä»¥ä¸‹èµ„æ–™ä»…ä¾›å­¦ä¹ ç ”ç©¶ä½¿ç”¨ï¼Œç‚¹å‡»é“¾æ¥å¯ç›´æ¥é¢„è§ˆã€‚</p>

  <input type="text" id="searchInput" placeholder="ğŸ” æ ¹æ®æ ‡é¢˜æœç´¢ä¿å­˜çš„ç½‘é¡µ..." />
  <div id="loading">æ­£åœ¨åŠ è½½æ–‡ä»¶åˆ—è¡¨ï¼Œè¯·ç¨å€™...</div>

  <ul id="mhtmlList"></ul>
  <div id="noResults">æœªæ‰¾åˆ°ç›¸å…³å†…å®¹</div>

  <!-- è¿”å›é¡¶éƒ¨ / åº•éƒ¨æŒ‰é’® -->
  <div class="scroll-buttons">
    <button onclick="window.scrollTo({ top: 0, behavior: 'smooth' });">â†‘ è¿”å›é¡¶éƒ¨</button>
    <button onclick="window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });">â†“ è·³è½¬åˆ°åº•éƒ¨</button>
  </div>

  <script>
    // âš ï¸ æ”¹æˆä½ çš„çœŸå®ç”¨æˆ·åå’Œä»“åº“å âš ï¸
    const owner      = "Ada-Ren";                // ä½ çš„ GitHub ç”¨æˆ·å
    const repo       = "personal-legal-archive"; // ä»“åº“å
    const rootFolder = "mhtml";                  // å­˜æ”¾æ–‡ä»¶çš„æ ¹ç›®å½•

    // æ”¯æŒçš„æ‰©å±•å
    const extsAll       = [".html", ".mhtml", ".mht", ".pdf"];
    const extsNeedTitle = [".html", ".mhtml", ".mht"];

    // localStorage ç¼“å­˜è®¾ç½®
    const CACHE_KEY     = "ada-law-commit-cache-v1";
    const CACHE_TTL_MS  = 24 * 60 * 60 * 1000; // 24 å°æ—¶

    // è¯»å–ç¼“å­˜
    function loadCache() {
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return {};
        const data = JSON.parse(raw);
        if (typeof data === "object" && data !== null) return data;
      } catch (e) {
        console.warn("è¯»å–ç¼“å­˜å¤±è´¥ï¼š", e);
      }
      return {};
    }

    // ä¿å­˜ç¼“å­˜
    function saveCache(cache) {
      try {
        localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
      } catch (e) {
        console.warn("å†™å…¥ç¼“å­˜å¤±è´¥ï¼š", e);
      }
    }

    // è·å–ç¼“å­˜ä¸­çš„æ—¶é—´ï¼ˆå¦‚æœæœªè¿‡æœŸï¼‰
    function getCachedDate(cache, path) {
      const entry = cache[path];
      if (!entry) return null;
      if (!entry.date || !entry.fetchedAt) return null;
      const age = Date.now() - entry.fetchedAt;
      if (age > CACHE_TTL_MS) return null; // è¿‡æœŸ
      return entry.date;
    }

    // è®¾ç½®ç¼“å­˜
    function setCachedDate(cache, path, isoString) {
      cache[path] = {
        date: isoString,
        fetchedAt: Date.now()
      };
    }

    // è·å–æ–‡ä»¶æœ€è¿‘ä¸€æ¬¡æäº¤æ—¶é—´ï¼ˆå¸¦ç¼“å­˜ï¼‰
    async function fetchFileCommitTimeWithCache(path, cache) {
      const cached = getCachedDate(cache, path);
      if (cached) return cached;

      try {
        const apiUrl = `https://api.github.com/repos/${owner}/${repo}/commits?path=${encodeURIComponent(path)}&page=1&per_page=1`;
        const res = await fetch(apiUrl);
        if (!res.ok) return null;
        const data = await res.json();
        if (Array.isArray(data) && data[0]?.commit?.author?.date) {
          const iso = data[0].commit.author.date;
          setCachedDate(cache, path, iso);
          return iso;
        }
      } catch (e) {
        console.warn("è¯»å–æäº¤æ—¶é—´å¤±è´¥ï¼š", path, e);
      }
      return null;
    }

    // å‹å¥½çš„æ—¥æœŸæ˜¾ç¤º
    function formatDate(isoString) {
      if (!isoString) return "";
      const d = new Date(isoString);
      if (Number.isNaN(d.getTime())) return "";
      return d.toLocaleDateString("zh-CN", {
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      });
    }

    // è¯»å–æŸä¸ªç›®å½•ï¼ˆç›¸å¯¹ä»“åº“æ ¹è·¯å¾„ï¼Œä¾‹å¦‚ "mhtml" æˆ– "mhtml/Guide"ï¼‰
    async function fetchDir(path) {
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      const res = await fetch(apiUrl);
      if (!res.ok) {
        const text = await res.text();
        console.error("GitHub API è¯·æ±‚å¤±è´¥ï¼š", path, res.status, text);
        throw new Error("GitHub API è¯·æ±‚å¤±è´¥ï¼š" + res.status);
      }
      const data = await res.json();
      if (!Array.isArray(data)) {
        throw new Error("GitHub API è¿”å›çš„ä¸æ˜¯æ•°ç»„ï¼š" + typeof data);
      }
      return data;
    }

    // é€’å½’éå†ç›®å½•ï¼Œæ”¶é›†æ‰€æœ‰ç¬¦åˆæ‰©å±•åçš„æ–‡ä»¶
    async function walkFolder(path) {
      const entries = await fetchDir(path);
      let files = [];

      for (const item of entries) {
        if (item.type === "dir") {
          const subFiles = await walkFolder(item.path);
          files = files.concat(subFiles);
        } else if (item.type === "file") {
          const lower = item.name.toLowerCase();
          if (extsAll.some(ext => lower.endsWith(ext))) {
            files.push(item); // item.path å½¢å¦‚ "mhtml/Guide/index000.html"
          }
        }
      }
      return files;
    }

    // ä» html/mhtml ä¸­æå– <title>
    async function extractTitleFromFile(path) {
      try {
        const res = await fetch(path);
        if (!res.ok) {
          console.warn("è·å–æ–‡ä»¶å¤±è´¥ï¼š", path, res.status);
          return null;
        }
        const text = await res.text();
        const match = text.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
        if (match && match[1]) {
          return match[1].trim();
        }
      } catch (e) {
        console.error("è§£ææ ‡é¢˜å¤±è´¥ï¼š", path, e);
      }
      return null;
    }

    // ç”¨æ–‡ä»¶åå…œåº•æ ‡é¢˜
    function filenameToTitle(name) {
      return name
        .replace(/\.(html|pdf|mhtml|mht)$/i, "")
        .replace(/[_\-]+/g, " ")
        .trim();
    }

    function renderList(items) {
      const listEl   = document.getElementById("mhtmlList");
      const loading  = document.getElementById("loading");
      const noResult = document.getElementById("noResults");

      loading.style.display = "none";
      listEl.innerHTML = "";

      if (!items.length) {
        noResult.style.display = "block";
        return;
      } else {
        noResult.style.display = "none";
      }

      // æŒ‰æ—¶é—´å€’åºæ’åºï¼ˆæœ€è¿‘æ›´æ–°æ—¶é—´åœ¨æœ€ä¸Šé¢ï¼‰
      items.sort((a, b) => {
        // æ²¡æœ‰æ—¶é—´çš„æ”¾æœ€å
        if (a.sortTime === b.sortTime) {
          return a.title.localeCompare(b.title, "zh");
        }
        return b.sortTime - a.sortTime;
      });

      items.forEach(item => {
        const li = document.createElement("li");
        li.dataset.searchText = item.title.toLowerCase();

        li.innerHTML = `
          ğŸ”– <a href="${item.url}" target="_blank">${item.title}</a>
          <div class="file-meta">
            ${item.fileName}
            ${item.displayDate ? " Â· " + item.displayDate : ""}
          </div>
        `;
        listEl.appendChild(li);
      });
    }

    function setupSearch() {
      const input     = document.getElementById("searchInput");
      const noResults = document.getElementById("noResults");
      const loading   = document.getElementById("loading");

      input.addEventListener("input", () => {
        const keyword = input.value.trim().toLowerCase();
        const items   = Array.from(document.querySelectorAll("#mhtmlList li"));
        let visibleCount = 0;

        items.forEach(li => {
          const text  = li.dataset.searchText || "";
          const match = !keyword || text.includes(keyword);
          li.style.display = match ? "" : "none";
          if (match) visibleCount++;
        });

        // åªæœ‰åœ¨åŠ è½½å®Œæˆåæ‰æ ¹æ®æœç´¢ç»“æœæ˜¾ç¤ºâ€œæœªæ‰¾åˆ°â€
        if (loading.style.display === "none") {
          noResults.style.display = visibleCount === 0 ? "block" : "none";
        }
      });
    }

    async function init() {
      const loading = document.getElementById("loading");
      loading.style.display = "block";

      let cache = loadCache();

      try {
        const files = await walkFolder(rootFolder);

        const items = await Promise.all(
          files.map(async f => {
            const lower = f.name.toLowerCase();
            const path  = f.path; // å¦‚ "mhtml/index000.html" æˆ– "mhtml/Guide/index000.html"

            let title = null;
            if (extsNeedTitle.some(ext => lower.endsWith(ext))) {
              title = await extractTitleFromFile(path);
            }
            if (!title) {
              title = filenameToTitle(f.name);
            }

            const commitIso = await fetchFileCommitTimeWithCache(path, cache);
            const sortTime  = commitIso ? new Date(commitIso).getTime() : 0;
            const displayDate = commitIso ? formatDate(commitIso) : "";

            return {
              fileName: f.path,   // æ˜¾ç¤ºå®Œæ•´è·¯å¾„
              title,
              url: path,
              sortTime,
              displayDate
            };
          })
        );

        // æ‰€æœ‰ commit æ—¶é—´è·å–å®Œæ¯•åå†ç»Ÿä¸€å†™å›ç¼“å­˜
        saveCache(cache);

        renderList(items);
        setupSearch();
      } catch (err) {
        console.error("åˆå§‹åŒ–å‡ºé”™ï¼š", err);
        const noResults = document.getElementById("noResults");
        loading.style.display = "none";
        noResults.style.display = "block";
        noResults.textContent = "åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚";
      }
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
